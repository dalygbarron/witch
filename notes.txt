screen is 16 32x32 tiles wide and 14 tall. That means we can have levels that
are 4 screens wide and a little over 2 tall without having to do any spicy
stuff. Frankly, for the style of game I am trying to make, I think that is
perfectly acceptable.

ok so to write to oam we set the table select bit in $2103 because there is the
big table where every sprite has 2 bytes, and the small table where each sprite
has 2 bits. Before that we just set the write address at $2102. As far as I can
tell writing to the large table obviously requires 2 successive writes, but I
think you can just do one write to the small table thankfully.

Ok I think I have an issue where the sprite buffer is being put somewhere that
overlaps with other stuff and is maybe in the ROM I dunno. Anyway I need to fix
that.


=== Creation, storage, and setting up of level data ===
Actually you know what, we really need to be able to store a top down level and
a side on level in their own formats because they contain important but
different information. Unless we can somehow make a generalised thing that works
for both, but for example even being able to store what song a level could play
is important, as is storing where enemies are and all that shit.

So the various key value things like size, background colour, music, etc, can
probably be stored as a couple of bytes at the start. The tile data itself can
probably just be stored as 2 bytes but maybe with RLE. Actually yeah I think
RLE would be very easy to decode and I can implement it maybe in such a way that
it uses some unused information in the byte that determines palette. I don't
care too much about flipping and that kind of thing, and also I only need 8 bits
for tile tbh.

So presumably one of our leading bytes will also tell us how many layers there
are in this map, so it can automatically load them in. The rest of the leading
information probably needs to be made available to the code after it loads in
the map so then it can do whatever with it.

So then, how do we store enemies in a way that doesn't fuck up other stuff? we
could make it that one of those bits in the second byte indicates that there
will actually be a third byte, and in that third byte a callback gets triggered
that lets you do some shit. That means we can use that for enemies in the
enemies part and other stuff in the other parts and we also have the location
already known because it's where that tile is. Only thing there is we have to
break up the RLE which will make it slightly harder to export but I can deal
with that.

So for those leading bytes we will have to probably figure out what strings in
tiled equal what things in the engine and either order them correctly or
prefix them with another byte that tells you what they mean. If we use the
prefix approach I guess we can make it use a callback or something.

Because empty spaces should not be visible, we do not need to fill them with
anything in particular so we can hypothetically just skip over them, but we do
need to remember that the size of the map is a multiple of 32x32. One possible
way to make this easier to deal with would be to just make the exporter always
export a multiple of 32x32 and fill the rest with 0s and let RLE do it's thing.
We still store the real size of the map for camera purposes.

So, the final problem is that maps are stored in 32x32 chunks rather than
contiguously. I guess the solution is just that we export the same way and when
we import we keep it in mind. I guess we will calculate the number of these sub
maps based on the purported map size. Hopefully we can find space to store that
data during the import process.

Oh yeah one other thing. Tiled doesn't handle multiple palettes so what are we
to do with that? I think with tiled we can set the default palette per tile.
We could implement a thingy for changing this per instance with the same logic
as implementing enemies later but I will not bother unless I decide I need it.

Oh yeah, it would also be cool if we were able to export a pathing map. This
would not use RLE but would encode each tile as one bit based on whether or not
things can pass through it. Actually on second hand maybe this should
be optionally generated by the code and stored in a fixed memory address for the
currently used map.

So we will have one subroutine that loads a given layer from a given place in
data. This just needs to know the size in 32x32 units. The other subroutine
loads a whole map and does all the other stuff like setting the bg colour and
music etc. The layer loading subroutine can run the enemy callback fine because
if you dont want that you can just pass an empty callback.


=== Outputting sprite data ===
yeah before we can really even talk about making levels we need to figure out
how we are going to be outputting image data. Right now I have tried to use two
tools and neither was ideal. Firstly we have aseprite which with a plugin (and
some hacking the plugin) can export broken tile data but correct palette data,
and we have YYCHR or whatever it's called which can output correct tile data but
broken palette data and is not really hackable. Aseprite is also a much nicer
drawing program but it does not really handle palette switching which
is a fairly significant handicap unless we want to only be able to use 15
colours for every single tile in the game.

Please sweet baby jesus protect me from the temptation to build my own snes
graphics tool completely from scratch.

I hate to say this dude, but it's actually kinda looking like I am going to have
to do so. I propose we aim to create a replica of YYCHR (minus the features I
don't need), except it actually exports to the correct palette format, and we
make it open source and cross platform and ideally use a gui lib that isn't
torture. I didn't mind wxwidgets in the past other than the fact that it crashes
and has no hardware acceleration which I think we will need since I want to be
able to enlarge my window and zoom high as hell. I will design an interface
later since YYCHR's doesn't go so well with scrolling. Maybe there will be a
thick sidebar holding the palette viewer and overview of the image, then the
rest is the zoomed type of view.

Yeah so I think if I remember right a palette thingy has 